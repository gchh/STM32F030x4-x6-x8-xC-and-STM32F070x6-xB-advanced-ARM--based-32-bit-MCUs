# Universal synchronous asynchronous receiver transmitter (USART)  
## 简介  
通用同步异步收发器（USART）提供了一种灵活的方式，与要求工业标准NRZ异步串行数据格式的外部设备进行全双工数据交换。USART使用可编程波特率发生器，提供很宽范围的波特率。  
它支持同步单向通信和半双工单线通信，以及多处理器通信。它也支持Modem调制解调器流控操作（CTS/RTS）。  
使用DMA（直接存储器存取）配置多个缓冲区，可以实现高速数据通信。  
## USART主要特性  
- 全双工异步通信  
- NRZ标准格式（mark标记/space空格）  
- 配置16倍或8倍过采样，提供速度和时钟公差之间灵活的选择  
- 当时钟频率时48MHz，且采用8倍过采样率时，通用可编程收发波特率可以达到6Mbit/s  
- 方便的波特率编程  
- 自动波特率检测  
- 可编程的数据字长（8位或9位）  
- 可编程的数据顺序，MSB最高位或LSB最低位在前  
- 可配置的停止位（1或2个停止位）  
- 用于同步通信的同步模式和时钟输出  
- 单线半双工通信  
- 使用DMA实现连续通信  
- 使用DMA将收到/发送的字节缓存到预留的SRAM区域中  
- 分开的发送和接收使能位  
- 分开的发送和接收信号极性控制  
- 可交换的Tx/Rx引脚配置  
- 用于Modem调制解调器和RS-485收发器的硬件流控制  
- 通信控制/错误检测标志  
- 奇偶校验控制：  
　- 发送奇偶校验位  
　- 检查接收的数据字节的奇偶性  
- 十四个具有标志位的中断源  
- 多处理器通信  
- 如果地址不匹配，USART进入静默模式  
- 从静默模式唤醒（检测到线路空闲或地址匹配标记）  
## USART配备  
![](https://i.imgur.com/rwosfMn.png)  
![](https://i.imgur.com/9fcdvIG.png)  
## USART功能描述  
任何USART双向通信都需要至少2个引脚：RX接收数据和TX发送数据：  
- RX：接收数据输入引脚。过采样技术用于数据恢复，通过鉴别有效的输入数据和噪声。  
- TX：发送数据输出引脚。当发送器关闭时，该输出引脚回到其I/O口配置状态。当发送器启动，但未发送数据时，TX引脚是高电平。在单线模式，该I/O口用作发送和接收数据。  
正常USART模式下，串行数据通过这些引脚发送和接收。数据帧由以下组成：  
- 发送或接收前保持线路空闲  
- 一个起始位  
- 一个数据字（8位或9位），最低有效位在前  
- 1个或2个停止位，指示帧结束  
- USART接口使用波特率发生器  
- 一个状态寄存器USART_ISR  
- 接收和发送数据寄存器USART_RDR和USART_TDR  
- 一个波特率寄存器USART_BRR  
下面的引脚在同步模式下需要：  
- CK：时钟输出。该引脚为同步发送，输出发送数据时钟，类似于SPI主模式（起始位和停止位没有时钟脉冲，最后一位数据软件可选是否发送时钟脉冲）。同时，RX可以同步接收数据。这可以用于控制带移位寄存器的外设。时钟相位和极性可由软件编程。  
下列引脚用于RS232硬件流控制模式：  
- CTS：当高电平时，在当前发送结束后阻止数据发送  
- RTS：低电平，指示USART准备好接收数据  
下面的引脚用于RS485硬件控制模式：  
- DE：驱动器使能，用于激活外部收发器的发送模式  
注：DE和RTS共享同一个引脚。  
![](https://i.imgur.com/y7GnxBD.png)  
### USART字符说明  
通过USART_CR1寄存器中的M位（第12bit：M0），可以编程选择8位或9位字长。  
- 8位字符长度：M0=0  
- 9位字符长度：M0=1  
默认情况下，TX和RX信号在起始位时为低电平，而在停止位时为高电平。  
通过极性配置控制，可以分别对TX或RX的这些值取反。  
空闲字符可以理解为整个帧每一位都为1。  
断开字符可以理解为每一位都为0的帧。在断开帧的结尾，发送器会插入2个停止位。  
发送器和接收器有共同的波特率发生器驱动，发送和接收各自的使能位置1后，将为其产生时钟。  
![](https://i.imgur.com/LCrh5yZ.png)  
![](https://i.imgur.com/2ZZr5n5.png)  
注：这两幅图有差异，感觉第2幅图才是正确的，符合断开字符的描述。  
### USART发送器  
发送器可以发送8位或9位的数据字，取决于M位的状态。发送使能位TE必须置1，以激活发送器功能。发送移位寄存器中的数据输出到TX引脚上，同时相应的时钟脉冲输出在CK引脚上。  
#### 字符发送  
USART发送时，默认配置下，数据的最低有效位首先移出到TX引脚上。在此模式下，USART_TDR寄存器充当了一个内部总线和发送移位寄存器之间的缓冲器（TDR）（见图226）。  
每个字符前面都有一个起始位，它是持续一个位周期的逻辑低电平。字符以配置的1个或2个停止位结束。  
注：在向USART_TDR寄存器写入要发送的数据之前必须先将TE位置1。  
TE位在发送数据期间不能复位。否则，会冻结波特率计数器，导致TX引脚上的数据损坏，当前正在发送的数据就会丢失。  
TE位置1后，将发送一个空闲帧。  
#### 可配置的停止位  
跟随每个字符发送的停止位个数可以在控制寄存器2的第12和13位编程。  
- 1个停止位：停止位个数的默认值。  
- 2个停止位：正常的USART，单线模式和调制解调器模式，支持。  
发送的空闲帧包括停止位。  
发送的断开帧包括10个低电平位（M0=0）或11个低电平位（M0=1），其后紧跟2个停止位（见图228）。无法发送更长的断开帧（长度大于10或11位）。  
![](https://i.imgur.com/PzlGimn.png)  
#### 字符发送配置  
1. 配置USART_CR1中的M位确定字长。  
2. 配置USART_BRR寄存器确定波特率。  
3. 在USART_CR2中配置停止位个数。  
4. 将USART_CR1寄存器中的UE位置1，使能USART。  
5. 如果采用多缓冲器通信，在USART_CR3中选择DMA使能（DMAT）。按照多缓冲器通信的说明配置DMA寄存器。  
6. 将USART_CR1中的TE位置1，发送一个空闲帧作为第一次发送。  
7. 向USART_TDR寄存器中写入要发送的数据（这将清零TXE位）。在单缓冲器的情况下，对每个要发送的数据重复该步骤。  
8. 将最后一个数据写入USART_TDR寄存器后，等待TC=1。它表示最后一帧数据发送完成。在禁止USART或进入停机模式之前，可以用它来确认发送是否完成，以免破环最后一次发送。  
###### USART transmitter configuration code example  

	/* (1) Oversampling by 16, 9600 baud */
	/* (2) 8 data bit, 1 start bit, 1 stop bit, no parity */
	USART1->BRR = 480000 / 96; /* (1) */
	USART1->CR1 = USART_CR1_TE | USART_CR1_UE; /* (2) */  
#### 单字节通信  
清零TXE位总是通过向发送数据寄存器写数据来执行的。  
TXE位由硬件置位，它表示：  
- 数据已经从USART_TDR寄存器转移到的移位寄存器中，且数据发送已经开始。  
- USART_TDR寄存器是空的。  
- 下一个数据可以写入USART_TDR寄存器中，而不会覆盖前一个数据。  
###### USART transmit byte code example  

	/* Start USART transmission */
	USART1->TDR = stringtosend[send++]; /* Will inititiate TC if TXE is set*/  
如果TXEIE位置1，TXE=1会产生中断。  
在发送中，对USART_TDR寄存器的写操作将数据存入TDR寄存器；此后，在当前正在进行的发送结束后，该数据复制进移位寄存器。  
未发送时，对USART_TDR寄存器的写操作会将数据直接放入移位寄存器，数据发送开始时，TXE位会被置1。  
如果一帧发送完毕（停止位发送后），此时TXE位还是1，那么，TC位将被置1。如果USART_CR1寄存器中的TCIE位置1，此时还会产生一个中断。  
向USART_TDR寄存器写入最后一个要发送的数据后，在禁止USART或设置微控制器进入低功耗模式之前，必须等待TC=1。  
![](https://i.imgur.com/pPeiG8A.png)  
###### USART transfer complete code example  

	if ((USART1->ISR & USART_ISR_TC) == USART_ISR_TC)
	{
		if (send == sizeof(stringtosend))
		{
			send=0;
			USART1->ICR |= USART_ICR_TCCF; /* Clear transfer complete flag */
		}
		else
		{
			/* clear transfer complete flag and fill TDR with a new char */
			USART1->TDR = stringtosend[send++];
		}
	}  
#### 断开字符  
将SBKRQ位置1，发送一个断开字符。断开帧的长度取决于M位（见图227）。  
如果SBKRQ位被置1，将在完成当前字符发送后，在TX上发送断开字符。SBKF位会在SBKRQ=1时置1，并在断开字符发送完成时由硬件清零（在断开字符后的停止位发送期间）。USART在断开字符后插入2个停止位，以确保下一帧起始位的识别。  
在应用需要在之前插入的所有数据（包括尚未发送的数据）后发送断开字符的情况下，在SBKRQ位置1之前需要确定TXE=1。  
#### 空闲字符  
将TE位置1，USART会在第一个数据帧之前首先发送一个空闲字符。  
### USART接收器  
USART接收8位或9位的数据字，取决于USART_CR1寄存器中M位的状态。   
#### 起始位侦测  
起始位侦测顺序是一样的，不管是8倍过采样还是16倍过采样。  
在USART中，当辨识出一个特定的采样序列，就认为侦测到一个起始位。该序列是：1 1 1 0 X 0 X 0 X 0 X 0 X 0 X 0。  
![](https://i.imgur.com/DFgCZeH.png)  
注：如果该序列不完整，则，起始位检测终止，接收器返回空闲状态（无标志位置1）等待下降沿。  
如果3个采样位都是0（在第3、5、7位的第一次采样3位都是0，在第8、9、10位的第二次采样3位也都是0），则可以确认收到起始位（RXNE标志置1，如果RXNEIE=1会产生中断）。  
下列情况也可以认为收到起始位（RXNE标志置1，如果RXNEIE=1会产生中断），但是噪声标志NF会置1：  
a) 2次采样，3个采样位中有2位是0  
b) 2次采样，其中一次采样的3个采样位中有2位是0，另一次采样3个采样位都是0  
如果a和b条件都不满足，则中止起始位检测，接收器回到空闲状态（无标志位置1）。  
#### 字符接收  
在USART接收期间，数据的最低有效位（默认配置）首先通过RX引脚移入。这种情况下，USART_RDR寄存器可以被看作是内部总线和接收移位寄存器之间的缓冲器（RDR）。  
##### 字符接收配置步骤  
1. 配置USART_CR1中的M位，确定字长。  
2. 配置USART_BRR，确定波特率。  
3. 在USART_CR2中配置停止位个数。  
4. 将USART_CR1中的UE位置1,使能USART。  
5. 如果采用多缓冲器通信，配置USART_CR3中的DMA使能位（DMAR）。根据多缓冲器通信的说明配置DMA寄存器。  
6. 将USART_CR1中的RE位置1，使能接收器，开始侦测起始位。  
###### USART receiver configuration code example  

    /* (1) oversampling by 16, 9600 baud */
    /* (2) 8 data bit, 1 start bit, 1 stop bit, no parity, reception mode */
    USART1->BRR = 480000 / 96; /* (1) */
    USART1->CR1 = USART_CR1_RXNEIE | USART_CR1_RE | USART_CR1_UE; /* (2) */  
当接收到一个字符时：  
- RXNE位置1，表示移位寄存器的内容已经传送到RDR。也就是，数据已经被接收，并可以读取（以及相关的错误标志）。  
- 如果RXNEIE位为1，还会产生中断。  
- 如果接收期间检测到帧错误、噪声或溢出错误，相应的错误标志位会置1。PE标志也会和RXNE一起被置1。  
- 在多缓冲器通信时，每接收一个字节后RXNE都会被置1，并由DMA读取接收数据寄存器而被清零。  
- 在单缓冲器模式下，RXNE位由软件读USART_RDR寄存器而被清零。RXNE标志也可以通过将USART_RQR中的RXFRQ位置1,而被清零。RXNE位必须在下一个字符接收结束之前被清零，以免发生溢出错误。  
###### USART receive byte code example  

    if ((USART1->ISR & USART_ISR_RXNE) == USART_ISR_RXNE)
    {
        chartoreceive = (uint8_t)(USART1->RDR); /* Receive data, clear flag */
    }  
#### 断开字符  
当收到断开字符后，USART会像帧错误一样处理它。  
#### 空闲字符  
检测到空闲帧时，会和接收到数据一样处理它；另外，如果IDLEIE位置1，还将产生中断。  
#### 溢出错误  
当RXNE=1时，又接收到一个字符，会导致溢出错误。新接收到的字符不会从移位寄存器传送到RDR寄存器中，直到RXNE位清零。  
每接收一个字节后，RXNE标志都会置1。如果在下一个数据已经被接收到或上一个DMA请求还未处理时RXNE标志被置1，则会产生溢出错误。当一个溢出错误发生时：  
- ORE位置1。  
- RDR中的内容不会丢失。读USART_RDR依然能得到前次数据。  
- 移位寄存器的内容会被覆盖；溢出发生后，接收到的数据都将丢失。  
- RXNEIE位和EIE位任何一个置1，都将产生中断。  
- 将USART_ICR中的ORECF位置1，会清除ORE位。  
注：当ORE位置1时，表明至少有1个数据已经丢失。有2种可能： 
- 如果RXNE=1，RDR接收寄存器中还有最后一个有效数据，可以被读取。  
- 如果RXNE=0，最后一个有效数据已经读取，RDR中已没有数据可读取。收到新数据（会丢失）的同时读取最后一个有效数据，会发生此种情况。  
#### 选择时钟源和适当的过采样方法  
时钟源的选择通过时钟控制系统完成（参见复位和时钟控制（RCC）章节）。在使能USART（UE位置1）之前，必须选择好时钟源。  
必须根据2个标准来选择时钟源：  
- USART可能会在低功耗模式下使用  
- 通信速度  
时钟源频率是f<sub>CK</sub>。  
时钟源决定了通信速度范围（尤其是最大通信速度）。  
接收器采用不同的用户可配置的过采样技术，将有效输入和噪声区分开来，从而实现数据恢复。这实现了最大通信速度和抗噪声/时钟误差之间的平衡。  
通过USART_CR1中的OVER8位选择过采样是波特率的8倍或16倍（图231和232）。  
根据应用：  
- 选择8倍过采样（OVER8=1）以获得较高的速度（高达f<sub>CK</sub>/8）。这种情况下，接收器对时钟偏差的最大容忍度会降低。  
- 选择16倍过采样（OVER8=1）会提高接收器对时钟偏差的容忍度。这种情况下，最大速度限制在f<sub>CK</sub>/16，其中f<sub>CK</sub>为时钟源频率。  
配置USART_CR3中的ONEBIT位，选择用于评估逻辑电平的方法。有2种选择：  
- 根据接收位中央的3次采样进行多数票决。这种情况下，当3才采样结果不等时，NF位置1。  
- 接收位的中央进行单次采样。  
根据不同的应用：  
- 在噪声环境下工作时，选择3次采样多数票决的方法（ONEBIT=0）；当检测到噪声时，抛弃该数据，因为它表明在采样过程中有干扰。  
- 在线路无噪声时，选择单次采样的方法（ONEBIT=1），以提高接收器对时钟偏差的容忍度。在这种情况下，NF位永远不会被置位。  
当在帧中检测到噪声：  
- NF位在RXNE位的上升沿被置1。  
- 无效的数据仍然会从移位寄存器转移到USART_RDR寄存器中。  
- 在单字节通信的情况下不会产生中断。但是和NF位同时置位的RXNE位可以产生中断。在多缓冲器通信的情况，如果USART_CR3中的EIE位置1，则会产生中断。  
将USART_ICR中的NFCF位置1，清除NF位。  
![](https://i.imgur.com/usaJ56U.png)  
![](https://i.imgur.com/1pF6npK.png)  
![](https://i.imgur.com/FsZPyyz.png)  
#### 帧错误  
失去同步、大量噪声、或是在预期的时间没有辨认出停止位，都会导致帧错误发生。  
检测到帧错误时：  
- FE位由硬件置1  
- 无效的数据仍然会从移位寄存器转移到USART_RDR中  
- 在单字节通信的情况下不会产生中断。但是和FE位同时置位的RXNE位可以产生中断。在多缓冲器通信的情况，如果USART_CR3中的EIE位置1，则会产生中断。  
将USART_ICR中的FECR位置1，清除FE位。  
#### 配置接收期间的停止位  
通过USART_CR2配置接收的停止位个数；正常模式下，可以是1位或2位。  
- 1个停止位：在第8、9和10个采样点对1个停止位进行采样。  
- 2个停止位：在第8、9和10个采样点对第1个停止位进行采样，如果发现帧错误，FE标志位会被置1。第2个停止位不检查帧错误。在第1个停止位结束时，RXNE标志会被置1。  
### USART波特率产生  
接收器和发送器（RX和TX）的波特率都在USART_BRR中设置为相同的值。  
#### 公式1：标准USART（包括SPI模式）（OVER8=0或1）的波特率  
OVER8=0时，Tx/Rx波特率=f<sub>CK</sub>/USARTDIV  
OVER8=1时，Tx/Rx波特率=(2×f<sub>CK</sub>)/USARTDIV  
USARTDIV是一个存放在USART_BRR寄存器中的无符号定点数。  
- 当OVER8=0时，BRR=USARTDIV。  
- 当OVER8=1时，  
　- BRR[2:0]=USARTDIV[3:0]>>1  
　- BRR[3]必须保持为0  
　- BRR[15:4]=USARTDIV[15:4]  
注：写入USART_BRR中的波特率新值会立即更新波特率计数器。因此，在通信过程中，不应该改变波特率寄存器的值。  
在8倍或16倍过采样的情况下，USARTDIV必须大于等于16（推测，是因为这样采样频率才不会超过f<sub>CK</sub>，不知是否如此？）。  
#### 如何从USART_BRR寄存器的值算出USARTDIV  
##### 例1  
f<sub>CK</sub>=8MHz，波特率9600：  
- OVER8=0，16倍过采样：USARTDIV=8000000/9600，BRR=USARTDIV=833d=0341h  
- OVER8=1，8倍过采样：USARTDIV=(2*8000000)/9600=1667d=683h，BRR[3:0]=3h>>1=1h，BRR=0x681  
##### 例2  
f<sub>CK</sub>=48MHz，波特率921.6K：  
- OVER8=0，16倍过采样：USARTDIV=48000000/921600，BRR=USARTDIV=52d=34h  
- OVER8=1，8倍过采样：USARTDIV=(2*48000000)/921600=104d=68h，BRR[3:0]=USARTDIV[3:0]>>1=8h>>1=4h，BRR=0x64  
![](https://i.imgur.com/weJyRTY.png)  
![](https://i.imgur.com/I7tiKHQ.png)  
### USART接收器对时钟偏差的容忍度  
